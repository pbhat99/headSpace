NoOp {
 name fxT_guiFinder
 tile_color 0xf8ff00ff
 note_font_size 13
 selected true
 xpos -98
 ypos -142
 hide_input true
 addUserKnob {20 fxT_guiFinderTAB l fxT_guiFinder}
 addUserKnob {26 info l "" +STARTLINE T "This node will find all '\$gui'-expressions in your\n nuke scripts and let you bake selected expressions.\n\nWhen any expression(s) are baked, a backup is stored\nto this node, to let you revert the action later."}
 addUserKnob {26 ""}
 addUserKnob {20 detailedInfoGROUP l "Detailed info" n 1}
 detailedInfoGROUP 0
 addUserKnob {26 detailedText l "" +STARTLINE T "<font color=grey><br/>\nExpression(s) that are baked using this tool,<br/>\nwill be stored as a check-box knob to this node.<br/><br/>\n\nThis is to keep a backup of the baked expression(s),<br/>\nand give you the option to restore it<br/>\nif there is a need to revert the action later.<br/><br/><br/>\n\n\n<b>BAKING, STORING, & RESTORING EXPRESSIONS:</b><br/><br/>\n\nWhen any \$gui expression(s) is baked,<br/>\nthe inverse expression will be set as a knob value for the knob.<br/>\nThis is done to ensure that the final comp-tree will look<br/>\nexactly the same as the rendered comp.<br/>\nVery useful when dealing with the comp-tree not matching<br/>\nthe rendered frames from the renderfarm.<br/><br/>\n\nSub-duplicates (duplicates with different index count),<br/>\nare not allowed to be stored. To bake and store<br/>\nsub-duplicates, please remove the knob in question<br/>\nfrom this node first by using the clear-button.<br/><br/>\n\nWhen storing or restoring duplicate values, you will be<br/>\ngiven the option to either overwrite or skip the<br/>\nbake or restore process on the knob in question.<br/><br/>\n\nThis tool will also check if nodes exist, and if expressions<br/>\nexist on the knob before storing or restoring any \$gui expressions.<br/>\nIf expressions exist, you will be given the option to<br/>\neither overwrite or skip the process on the knob in question.<br/>\n</font>"}
 addUserKnob {20 endGroup n -1}
 addUserKnob {26 ""}
 addUserKnob {22 findGuiExpressions l "find all '\$gui' expressions" t "click this button to find all '\$gui'-expressions in this nuke script" T "\"\"\"====================================================================================\nDEVELOPER: Tor Andreassen - www.fxtor.net  |  DATE: January 18, 2017  |  VERSION: v2.0\n====================================================================================\"\"\"\n\nclass ExpressionFinder( nukescripts.PythonPanel):\n\n    def __init__( self ):\n        nukescripts.PythonPanel.__init__( self, '\$Gui finder', 'guiFinder.panel')\n        self.setMinimumSize(550, 750)\n\n        self.counter = 0\n        self.header = nuke.Text_Knob(\"header\", \"\", \"<h3>\$GUI FINDER </h3>\")\n        self.info = nuke.Text_Knob(\"info\", \"\", \"<font color=grey>This tool will display all \$gui-expressions in this nuke script<br />incuding expressions inside groups.<br /><br />all expressions that includes the string '\$gui' will be displayed below\")\n        self.divider = nuke.Text_Knob(\"\", \"\", \"\" )\n        self.divider1 = nuke.Text_Knob(\"\", \"\", \"\" )\n        self.divider2 = nuke.Text_Knob(\"\", \"\", \"\" )\n\n        self.okButton = nuke.Script_Knob(\"Close\")\n        self.bakeSelected = nuke.PyScript_Knob(\"bakeSelected\",\"bake selected expressions\")\n        self.selectToggle = nuke.PyScript_Knob(\"selectToggle\",\"select toggle\")\n\n        self.addKnob(self.header)\n        self.addKnob(self.info)\n        self.addKnob(self.divider)\n        \n        self.storeNodeName = nuke.thisNode()\n        self.storeNode = nuke.thisNode().name()\n        self.searchString = '\$gui'\n\n        def search():\n        \n            for node in nuke.allNodes(recurseGroups=True):\n                node.setSelected(True) # select all in case something is selected\n                node.setSelected(False) # deselect all, to make sure nothing is selected (to ensure correct selection of nodes)\n        \n            myList = \[]\n            for node in nuke.allNodes(recurseGroups=True):\n                for knob in node.allKnobs():\n                    if knob.hasExpression():\n                        knobSize = knob.arraySize()\n                        for anim in knob.animations():\n                            knobIndex = anim.knobIndex()\n                            if knobSize == 1:\n                                expr = anim.expression()\n                            elif knobSize > 1:\n                                expr = anim.expression() +' index:'+str(knobIndex)\n                \n                            \n                            if ('\$gui' in expr):\n                                var = node.fullName()\n                                var2 = knob.name()\n                                var3 = var+var2\n                                var4 = var+\"\['\"+var2+\"']\"+': '+expr\n                                var5 = var+\"\['\"+var2+\"']\"\n                                myList.append(var4)\n            myList = set(myList)\n            myList = list(myList)\n\n\n            from collections import OrderedDict\n\n\n            temp = \[item.split('index:') for item in myList]\n\n            d = OrderedDict()\n\n            for i in temp:\n                if len(i) >= 2:\n                    d\[i\[0]] = i\[1] if i\[0] not in d else '\{\},\{\}'.format(d\[i\[0]],i\[1])\n                else: d\[i\[0]+' '] = '0'\n\n            myList = \['\{\}(index: \{\})'.format(*item) for item in d.items()]\n\n\n            myList.sort()\n\n            myListSorted = \[]\n            for i in myList:\n\n                iSplit = i.split()\n                i1 = iSplit\[:-2]\n                i1 =' '.join(i1)\n                i2 = iSplit\[-1]\n                i2 = i2\[:-1]\n                i2 = i2.replace(\",\",\"\")\n                i2 = list(i2)\n                i2 = \[int(t) for t in i2]\n                i2.sort()\n                i2 =\",\".join(map(str, i2))\n                i = i1+' (index: '+i2+')'\n                myListSorted.append(i)\n\n            myList = myListSorted\n\n            self.counter = len(myList)\n\n\n\n            for l in myList:\n                boxValue = 0\n                box = nuke.Boolean_Knob((l), l , boxValue)\n                box.setFlag(nuke.STARTLINE)\n\n                l = l.split()\n                l = l\[1]\n\n                box.setTooltip(l) \n                self.addKnob(box)\n\n        \n            if (len(myList) >= 1):\n                self.addKnob(self.divider1)\n                self.label = nuke.Text_Knob(\"\", \"\", \"<font color =green><b>%s\" % self.counter+ \" \$gui-expressions was found in this nuke script\" )\n            elif (len(myList) == 0):\n                self.label = nuke.Text_Knob(\"\", \"\", \"<font color =red><b>%s\" % self.counter+ \" \$gui-expressions was found in this nuke script\" )\n\n            myList = \[]\n\n        search()\n \n       \n\n        self.addKnob(self.label)\n        self.addKnob(self.divider2)\n        self.addKnob(self.selectToggle)\n        self.addKnob(self.bakeSelected)\n        self.addKnob(self.okButton)\n\n\n\n    #########################################\n    #   knob Change kill stuff in script:   #\n    #########################################\n\n    def knobChanged(self,knob):\n\n        with nuke.root():  #this will execute the code on the DAG's root level (for correct recount of expressions)      \n\n            if nuke.thisKnob().name() == \"bakeSelected\":\n\n                countMsg = set()\n                for name, knob in self.knobs().items():\n                    if knob.Class()== 'Boolean_Knob' and knob.value() == True:\n                        countMsg.add(knob)\n                        break\n\n                if len(countMsg) == 0:\n                    nuke.message('No expression-knob(s) are selected, no expression(s) to bake.')\n                else:\n\n                    myListUpdate = \[]\n                    dontRestoreList = \[]\n                    for name, knob in self.knobs().items():\n                        if knob.Class()== 'Boolean_Knob' and knob.value() == True:\n                            nodename, _, expr = name.partition(\":\")\n                            base = nodename.split('\[')\n                            baseName = base\[0]\n                            knobName = base\[1]\n                            knobName = knobName\[1:-2]\n                            ex = name.split()\[1]\n                            notEx= '!'+ex\n                            ind = name.split()\[3]\n                            ind = ind\[:-1]\n                            ind = ind.replace(\",\", \"\")\n                            indList = list(ind)  \n                            currentIndex = indList\n                            currentName = baseName+\"\['\"+knobName+\"']\"\n                            \n                            knobbyName = name.split()\n                            index0 = knobbyName\[0]\[:-1]\n                            del knobbyName\[:2]\n                            knobbyName.insert(0, index0)\n                            knobbyName = ' '.join(knobbyName)\n                            currentSubDupeName = baseName+\"\['\"+knobName+\"']: \"+ex+' (index: '+','.join(indList)+')'\n\n\n                            ###################################\n                            #   testing for sub-duplicates:   #\n                            ###################################\n\n                            duplicateIndexList = \[]\n\n                            for i in nuke.toNode(self.storeNode).knobs():\n                                if ('\[' in i):\n\n                                    nodeName = nuke.toNode(self.storeNode)\[i].label()\n                                    nodeName = nodeName\[12:-7]\n                                    nodeName = nodeName.replace('<font color=grey>','')\n                                    nodeName = nodeName.split('\[')\[0]\n\n                                    nodeKnob = nuke.toNode(self.storeNode)\[i].label()\n                                    nodeKnob = nodeKnob\[12:-7]\n                                    nodeKnob = nodeKnob.replace('<font color=grey>','')\n                                    nodeKnob = nodeKnob.split('\[')\[1]\n                                    nodeKnob = nodeKnob.split(']')\[0]\n                                    nodeKnob = nodeKnob\[1:-1]\n\n                                    nodeNameKnob = nodeName+\"\['\"+nodeKnob+\"']\"\n\n\n                                    nodeExpr = nuke.toNode(self.storeNode)\[i].label()\n                                    nodeExpr = nodeExpr\[12:-7]\n                                    nodeExpr = nodeExpr.replace('<font color=grey>','')\n                                    nodeExpr = nodeExpr.split(' ')\[1]\n\n                                    nodeIndex = nuke.toNode(self.storeNode)\[i].label()\n                                    nodeIndex = nodeIndex\[12:-7]\n                                    nodeIndex = nodeIndex.replace('<font color=grey>','')\n                                    nodeIndex = nodeIndex.split(' ')\[4]             \n                                    nodeIndex = nodeIndex\[:-1]\n                                    nodeIndex = nodeIndex.replace(\",\", \"\")\n\n                                    nodeIndexList = list(nodeIndex)\n\n\n                                    if currentName == nodeNameKnob:\n\n                                        for item in currentIndex:\n                                            if item in nodeIndexList:\n                                                duplicateIndexList.append(item)\n                                                tooltip =  nuke.toNode(self.storeNode)\[i].tooltip()\n                                                storedExprVal = i\n                                                storedExprVal_part0 = storedExprVal.split(\"']\")\[0]+\"']: \"\n                                                storedExprVal_part2 = storedExprVal.split(\"']\")\[1]\n                                                storedExprVal_part2 = storedExprVal_part2.split(':')\n                                                storedExprVal_part2 = ': '.join(storedExprVal_part2)\n                                                storedExprVal = storedExprVal_part0 + tooltip + ' ' + storedExprVal_part2\n\n                            # this is testing whether current value is a subDuplicate of any stored expression-knobs\n                            subDupe = 'no'\n                            if len(duplicateIndexList) >0 and not nuke.toNode(self.storeNode).knob(knobbyName):\n                                subDupe = 'yes'\n                                dontRestoreList.append(knobbyName)\n                                nuke.message ('<font color=orange>'+currentSubDupeName+'</font>'+'\\n\\n is a sub-duplicate of the stored expression:\\n\\n'+'<font color=orange>'+storedExprVal+'</font>'+'\\n\\nIf you wish to restore this value, plese manually remove it from the stored list by using the clear button first') \n                                continue\n\n\n                            #######################################\n                            #   END testing for sub-duplicates:   #\n                            #######################################\n\n\n\n                            #clear animation on knobs, and make sure the oposite of the \$gui is set as knobValue\n                            #this so that the node contains the same value that was used on the renderfarm\n\n                            duplicateList = \[]\n\n\n                            if subDupe == 'yes':\n                                duplicateList.append(name)\n                                pass\n\n                            # if knob is already stored, do this\n                            if nuke.toNode(self.storeNode).knob(knobbyName):\n                                theKnob = knobbyName\n\n                                tooltipEx = nuke.toNode(self.storeNode)\[knobbyName].tooltip()\n                                if nuke.ask(theKnob+'\\nis alread stored.\\n\\n Would you like to overwrite the stored expression\\n\\n'+'<font color=orange>'+tooltipEx+'</font>'+' with '+'<font color=orange>'+ex+'</font>'+' ?'):\n                                    nuke.toNode(self.storeNode).removeKnob(nuke.toNode(self.storeNode)\[theKnob])\n\n                                    knobType = nuke.toNode(baseName)\[knobName].Class()\n                                    # specific restore process for disable knobs (singleValue knob)\n                                    if knobType == 'Disable_Knob':\n                                        nuke.toNode(baseName)\[knobName].clearAnimated()\n                                        nuke.toNode(baseName)\[knobName].setExpression(notEx)\n                                        nonGuiVal = nuke.toNode(baseName)\[knobName].value()\n                                        nuke.toNode(baseName)\[knobName].clearAnimated()\n                                        nuke.toNode(baseName)\[knobName].setValue(nonGuiVal)\n                                    else:\n                                        for i in indList: #if it's not a singel Value knob, reach index for restore process\n                                            nuke.toNode(baseName)\[knobName].clearAnimated(int(i))\n                                            nuke.toNode(baseName)\[knobName].setExpression(notEx,int(i))\n                                            nonGuiVal = nuke.toNode(baseName)\[knobName].value(int(i))\n                                            nuke.toNode(baseName)\[knobName].clearAnimated(int(i))\n                                            nuke.toNode(baseName)\[knobName].setValue(nonGuiVal,int(i))\n                                else: \n                                    duplicateList.append(name)\n                                    pass\n\n\n\n                            #if knob is not stored, do this\n                            elif not nuke.toNode(self.storeNode).knob(knobbyName) and subDupe == 'no':\n                                knobType = nuke.toNode(baseName)\[knobName].Class()\n                                # specific restore process for disable knobs (singleValue knob)\n                                if knobType == 'Disable_Knob':\n                                    nuke.toNode(baseName)\[knobName].clearAnimated()\n                                    nuke.toNode(baseName)\[knobName].setExpression(notEx)\n                                    nonGuiVal = nuke.toNode(baseName)\[knobName].value()\n                                    nuke.toNode(baseName)\[knobName].clearAnimated()\n                                    nuke.toNode(baseName)\[knobName].setValue(nonGuiVal)\n                                else:\n                                    for i in indList: #if it's not a singel Value knob, reach index for restore process\n                                        nuke.toNode(baseName)\[knobName].clearAnimated(int(i))\n                                        nuke.toNode(baseName)\[knobName].setExpression(notEx,int(i))\n                                        nonGuiVal = nuke.toNode(baseName)\[knobName].value(int(i))\n                                        nuke.toNode(baseName)\[knobName].clearAnimated(int(i))\n                                        nuke.toNode(baseName)\[knobName].setValue(nonGuiVal,int(i))\n                \n                            \n                            for node in nuke.allNodes(recurseGroups=True):\n                                node.setSelected(True)\n                                node.setSelected(False)\n\n\n\n                    #####################\n                    #   update status:  #\n                    #####################\n\n                    for node in nuke.allNodes(recurseGroups=True):\n                        node.setSelected(True) # select all in case something is selected\n                        node.setSelected(False) # deselect all, to make sure nothing is selected (to ensure correct selection of nodes)\n                \n                    for node in nuke.allNodes(recurseGroups=True):\n                        for knob in node.allKnobs():\n                            if knob.hasExpression():\n                                for anim in knob.animations():\n                                    expr = anim.expression()\n                \n                                    if (self.searchString is None or self.searchString == ''):\n                                        break;\n                                    \n                                    elif (self.searchString in expr):\n                                        var = node.fullName()\n                                        var2 = knob.name()\n                                        var3 = var+var2\n                                        var4 = var+\"\['\"+var2+\"']\"+': '+expr\n                                        myListUpdate.append(var4)\n                                        node.setSelected(True)\n                                        nuke.zoomToFitSelected()\n\n                    #convert list to set to kill duplicates, then convert it back to list to keep list format for correct splitting later\n                    myListUpdate = set(myListUpdate)\n                    myListUpdate = list(myListUpdate)\n                    myListUpdate.sort()\n                    self.recount = (len(myListUpdate))\n                \n                \n                    if (len(myListUpdate) >= 1):\n                        self.label.setValue(\"<font color =green><b>%s\" % self.recount+ \" \$gui-expressions was found in this nuke script\")\n\n                   \n                    elif(len(myListUpdate) == 0):\n                        self.label.setValue(\"<font color =red><b>%s\" % self.recount+ \" \$gui-expressions was found in this nuke script\")\n\n\n                    #duplicateList = \[]\n                    #remove knobs that has been deleted, so the list is up to date\n                    for name, knob in self.knobs().items():\n                        if knob.Class()=='Boolean_Knob' and knob.value() == True:\n                            \n                            #store deleted values\n                            knobbyName = name.split()\n                            tooltip = knobbyName\[1]\n                            index0 = knobbyName\[0]\[:-1]\n                            del knobbyName\[:2]\n                            knobbyName.insert(0, index0)\n                            knobbyName = ' '.join(knobbyName)\n\n                            nameSplit = name.rsplit(' ',2)\n                            name1 = nameSplit\[0]\n                            name2 = ' (index: '+nameSplit\[-1]\n\n                            storeBox = (nuke.Boolean_Knob(knobbyName,'&nbsp;&nbsp;'+name1+'<font color=grey> '+name2+'</font>',0))\n                            storeBox.setFlag(nuke.STARTLINE)\n\n\n                            #if node is not already stored, store node\n                            if nuke.toNode(self.storeNode).knob(knobbyName):\n                                pass\n\n\n                            elif knobbyName in dontRestoreList:\n                                pass\n\n                            elif len(duplicateList) >0:\n                                pass\n\n\n                            else:\n                                nuke.toNode(self.storeNode).addKnob(storeBox)\n                                nuke.toNode(self.storeNode)\[knobbyName].setTooltip(tooltip)\n                                #remove knob so list is up to date\n                                self.removeKnob(knob)\n                                nuke.toNode(self.storeNode)\['restoreButton'].setVisible(True)\n                                nuke.toNode(self.storeNode)\['restoreButton'].setLabel('restore selected expressions')\n                                nuke.toNode(self.storeNode)\['clearButton'].setVisible(True)\n                                nuke.toNode(self.storeNode)\['clearButton'].setLabel('clear selected expressions')\n                                nuke.toNode(self.storeNode)\['selectToggle'].setVisible(True)\n                                nuke.toNode(self.storeNode)\['selectToggle'].setLabel('select toggle')\n\n\n                    #kill top divider line if all expressions is killed (for a nicer GUI look)\n                    if (len(myListUpdate) == 0):\n                        self.removeKnob(self.divider)\n\n\n        #####################################\n        #   select all checkboxes toggle:   #\n        #####################################\n\n        if nuke.thisKnob().name() == \"selectToggle\":\n            for name, knob in self.knobs().items():\n                if knob.Class()=='Boolean_Knob':\n                    knob.setValue(not knob.value())\n\n                    \nExpressionFinder().showModalDialog()" +STARTLINE}
 addUserKnob {22 restoreButton l "restore selected expressions" t "click this button to restore expressions for selected knobs" -STARTLINE +HIDDEN T "\"\"\"====================================================================================\nDEVELOPER: Tor Andreassen - www.fxtor.net  |  DATE: March 20, 2021  |  VERSION: v2.1\n====================================================================================\"\"\"\n\ntry:\n    from PySide import QtGui, QtCore\nexcept ImportError:\n    from PySide2 import QtCore\n    from PySide2 import QtWidgets as QtGui\n\n\n#import PySide.QtCore\n\nme = nuke.thisNode()\nforceReopen = 'no'\nforceRestore = 'no'\nrestoreAnswer = 'no'\nselectedKnobs = 'no'\nrestoreCounter = set()\nrebuildList = \[]\n\n\nfor node in nuke.allNodes(recurseGroups=True):\n    node.setSelected(True)\n    node.setSelected(False)\n\nfor knob in nuke.thisNode().knobs():\n    if '\[' in knob:\n        restoreCounter.add(knob)\n\nfor knob in restoreCounter:\n    if nuke.thisNode()\[knob].value() == True:\n        selectedKnobs = 'yes'\n        break\n\nif selectedKnobs == 'no':\n    nuke.message('no expression-knob(s) are selected, nothing to restore.')\nelif selectedKnobs == 'yes':\n\n\n    if nuke.ask('Are you sure you want to restore the selected expression(s)?'):\n        restoreAnswer = 'yes'\n\n    if restoreAnswer == 'yes':\n\n        missingNodes = \[]\n        restoredKnobsFinal = \[]\n\n        for i in nuke.thisNode().knobs():\n            notRestoredIndexList = \[]   # not restored knobs\n            restoredIndexList = \[]      # restored knobs\n            if ('\[' in i):\n                nodeName = nuke.thisNode()\[i].label()\n                nodeName = nodeName\[12:-7]\n                nodeName = nodeName.replace('<font color=grey>','')\n                nodeName = nodeName.split('\[')\[0]\n\n                nodeKnob = nuke.thisNode()\[i].label()\n                nodeKnob = nodeKnob\[12:-7]\n                nodeKnob = nodeKnob.replace('<font color=grey>','')\n                nodeKnob = nodeKnob.split('\[')\[1]\n                nodeKnob = nodeKnob.split(']')\[0]\n                nodeKnob = nodeKnob\[1:-1]\n\n                nodeExpr = nuke.thisNode()\[i].label()\n                nodeExpr = nodeExpr\[12:-7]\n                nodeExpr = nodeExpr.replace('<font color=grey>','')\n                nodeExpr = nodeExpr.split(' ')\[1]\n\n                nodeIndex = nuke.thisNode()\[i].label()\n                nodeIndex = nodeIndex\[12:-7]\n                nodeIndex = nodeIndex.replace('<font color=grey>','')\n                nodeIndex = nodeIndex.split(' ')\[4]             \n                nodeIndex = nodeIndex\[:-1]\n                nodeIndex = nodeIndex.replace(\",\", \"\")\n\n                nodeIndexList = list(nodeIndex)\n\n                #figure out arraySize and singleValue values \n                #this is used to trigger specific restore process if a user has set a singleValue expression on a stored dualValue expression\n                try:\n                    arraySize = nuke.toNode(nodeName)\[nodeKnob].arraySize()\n                    singleVal = nuke.toNode(nodeName)\[nodeKnob].singleValue()\n\n                    #converting arraySize to arrayList so it's loopable \n                    arrayList = \[]\n                    appendNum = 0\n                    while (appendNum < arraySize):\n                        arrayList.append(appendNum)\n                        appendNum = appendNum+1\n\n                # if there is problems with generating arraySize or singleVal due to nonExistent nodes for example, don't throw an error, this will make sure the script don't stop running due to an error\n                except:\n                    pass \n\n\n                if nuke.thisNode()\[i].value() == True:\n\n                    forceRestore = 'no'\n                    if nuke.exists(nodeName):\n                        #looping over inndex knobs\n                        indexLen = len(nodeIndexList)\n                        startIndexLen = indexLen\n                        for x in nodeIndexList:\n\n                            ##############################################################################################\n                            #   restore process if expression is set to singleValue but stored expression is dualValue   #\n                            ##############################################################################################\n\n                            if nuke.toNode(nodeName)\[nodeKnob].hasExpression(0) and (arraySize > 1) and (singleVal == True):\n                                currSetExpr = nuke.toNode(nodeName)\[nodeKnob].toScript()\n\n                                # generate correct display of stored expression\n                                if '\\\$gui' in currSetExpr or '!\\\$gui' in currSetExpr:\n                                    currSetExpr = currSetExpr\[2:-2]\n                                else:\n                                    currSetExpr = currSetExpr\[1:-1]\n\n                                if '\\\$gui' in currSetExpr:\n                                    currSetExpr = currSetExpr.replace(\"\\\$gui\", \"\$gui\")\n                                if '!\\\$gui' in currSetExpr:\n                                    currSetExpr = currSetExpr.replace('!\\\$gui', '!\$gui')\n                                else:\n                                    currSetExpr = currSetExpr\n\n                                singleValRestoreIndexes = \[]\n                                for x in nodeIndexList:\n                                    singleValRestoreIndexes.append(x)\n                                singleValRestoreIndexes = ','.join(singleValRestoreIndexes)\n\n                                currSetExpr = '<font color=orange>'+currSetExpr+' (singleValue)'+'</font>'\n                                nodeExprColor = '<font color=orange>'+nodeExpr+' (index '+singleValRestoreIndexes+')'+'</font>'\n\n                                if nuke.ask(nodeName+\"\['\"+nodeKnob+\"']\"+' already has an expression:\\n\\n'+currSetExpr+'\\n\\n\\nDo you want to remove this expression and replace it with the stored \$gui expression listed below ? \\n\\n'+nodeExprColor+'\\n\\n\\n\\nPS: knobs in array list that is not restored with a stored \$gui-expression will be set to the default knob value.'):\n                                    forceRestore = 'yes'\n\n                                    if nuke.exists(nodeName):\n                                        \n                                        nuke.toNode(nodeName)\[nodeKnob].clearAnimated()\n                                        for r in arrayList:\n                                            nuke.toNode(nodeName)\[nodeKnob].setValue(nuke.toNode(nodeName)\[nodeKnob].defaultValue(),int(r))\n                                        for x in nodeIndexList:\n                                            nuke.toNode(nodeName)\[nodeKnob].setExpression(nodeExpr,int(x))\n                                            restoredIndexList.append(x)\n\n                                        nuke.thisNode().removeKnob(nuke.thisNode()\[i])\n                                        break\n\n                                    else:\n                                        missingNodes.append(nodeName)\n                                        break\n\n                                else: #if the user say NO do this\n                                    for x in nodeIndexList:\n                                        notRestoredIndexList.append(x)\n                                    forceRestore = 'no'\n                                    break # if user say NO: break, this makes sure it only loops once, since you want to restore all the values in stead of asking to overwrite for every single index\n\n\n                            ################################################################################################\n                            # END  restore process if expression is set to singleValue but stored expression is dualValue  #\n                            ################################################################################################\n\n\n\n                            if nuke.toNode(nodeName)\[nodeKnob].hasExpression(int(x)):\n                                currSetExpr = nuke.toNode(nodeName)\[nodeKnob].toScript()\n                                currSetExpr = currSetExpr.split()\[int(x)]\n\n\n                                # generate correct display of stored expression\n                                if '\\\$gui' in currSetExpr or '!\\\$gui' in currSetExpr:\n                                    currSetExpr = currSetExpr\[2:-2]\n                                else:\n                                    currSetExpr = currSetExpr\[1:-1]\n\n                                if '\\\$gui' in currSetExpr:\n                                    currSetExpr = currSetExpr.replace(\"\\\$gui\", \"\$gui\")\n                                if '!\\\$gui' in currSetExpr:\n                                    currSetExpr = currSetExpr.replace('!\\\$gui', '!\$gui')\n                                else:\n                                    currSetExpr = currSetExpr\n\n\n                                currSetExpr = '<font color=orange>'+currSetExpr+'</font>'\n                                nodeExprColor = '<font color=orange>'+nodeExpr+'</font>'                                \n\n\n\n                                if nuke.ask(nodeName+\"\['\"+nodeKnob+\"']\"+' (index: '+str(x)+')'+' already has an expression:\\n\\n'+currSetExpr+'\\n\\nDo you want to remove this expression and replace it with the stored \$gui expression '+nodeExprColor+' ?'):\n                                    forceRestore = 'yes'\n\n                                    if nuke.exists(nodeName):\n                                        knobbyType = nuke.toNode(nodeName)\[nodeKnob].Class()\n                                        if knobbyType == 'Disable_Knob':\n                                            nuke.toNode(nodeName)\[nodeKnob].clearAnimated()\n                                            nuke.toNode(nodeName)\[nodeKnob].setExpression(nodeExpr)\n                                            nuke.thisNode().removeKnob(nuke.thisNode()\[i])\n                                            restoredIndexList.append(x)\n\n                                        else:\n                                            nuke.toNode(nodeName)\[nodeKnob].setValue(19,int(x)) #this will force the knob to be dualValueKnob (in the user changed it to a singleValueKnob) 19 is random nr (its being overwritten with the expression value so it does not matter what nr is used)\n                                            nuke.toNode(nodeName)\[nodeKnob].removeKey(int(x))\n                                            nuke.toNode(nodeName)\[nodeKnob].clearAnimated(int(x))\n                                            nuke.toNode(nodeName)\[nodeKnob].setExpression(nodeExpr,int(x))\n                                            restoredIndexList.append(x)\n                                            if indexLen == 1:\n                                                nuke.thisNode().removeKnob(nuke.thisNode()\[i])\n                                    else:\n                                        missingNodes.append(nodeName)\n                                        pass\n                                else:  #if the user say NO do this\n                                    notRestoredIndexList.append(x)\n                                    forceRestore = 'no'\n                                    if indexLen == 1 and len(notRestoredIndexList) != startIndexLen:\n                                        nuke.thisNode().removeKnob(nuke.thisNode()\[i])\n \n                                    elif indexLen == 1 and len(notRestoredIndexList) == startIndexLen:\n                                        pass\n\n                            else:\n                                if nuke.exists(nodeName):\n                                    knobbyType = nuke.toNode(nodeName)\[nodeKnob].Class()\n                                    if knobbyType == 'Disable_Knob':\n                                        nuke.toNode(nodeName)\[nodeKnob].clearAnimated()\n                                        nuke.toNode(nodeName)\[nodeKnob].setExpression(nodeExpr)\n                                        nuke.thisNode().removeKnob(nuke.thisNode()\[i])\n                                        restoredIndexList.append(x)\n                                    else:\n                                        nuke.toNode(nodeName)\[nodeKnob].setValue(19, int(x)) #this will force the knob to be dualValueKnob (in the user changed it to a singleValueKnob) 19 is random nr (its being overwritten with the expression value so it does not matter what nr one use)\n                                        nuke.toNode(nodeName)\[nodeKnob].removeKey(int(x))\n                                        nuke.toNode(nodeName)\[nodeKnob].clearAnimated(int(x))\n                                        nuke.toNode(nodeName)\[nodeKnob].setExpression(nodeExpr,int(x))\n                                        restoredIndexList.append(x)\n                                        if indexLen == 1:\n                                            nuke.thisNode().removeKnob(nuke.thisNode()\[i])\n                                else:\n                                    missingNodes.append(nodeName)\n                                    pass\n\n                            indexLen = indexLen-1\n\n\n                        ### this happens if these criterias are met: notRestoredIndexList has content AND knob is dualKnob, AND if at least one value was restored (user did not press yes on all index restore questions)\n                        if len(notRestoredIndexList)>0 and startIndexLen != 1 and len(notRestoredIndexList)!= startIndexLen:\n                            forceReopen = 'yes'\n                            notRestoredDisplay= ','.join(notRestoredIndexList) # message-display for not stored values\n                            restoredDisplay = ','.join(restoredIndexList) # message-display for stored values\n                            storeBoxRebuild = nuke.thisNode().addKnob(nuke.Boolean_Knob(nodeName+\"\['\"+nodeKnob+\"'] (index:\"+notRestoredDisplay+\")\", \"&nbsp;&nbsp;\"+nodeName+\"\['\"+nodeKnob+\"']: \"+nodeExpr+\"<font color=grey> \"+\" (index: \"+notRestoredDisplay+\")</font>\",\"tooltip\"))\n                            nuke.thisNode()\[nodeName+\"\['\"+nodeKnob+\"'] (index:\"+notRestoredDisplay+')'].setFlag(nuke.STARTLINE)\n                            nuke.thisNode()\[nodeName+\"\['\"+nodeKnob+\"'] (index:\"+notRestoredDisplay+')'].setTooltip(nodeExpr)\n\n                            restoredKnobsFinal.append (nodeName+\"\['\"+nodeKnob+\"']: \"+nodeExpr+' (index: '+restoredDisplay+')')\n                            rebuildList.append(x)\n\n\n                        if len(restoredIndexList) == startIndexLen:\n                            notRestoredDisplay= ','.join(notRestoredIndexList) # message-display for not stored values\n                            restoredDisplay = ','.join(restoredIndexList) # message-display for stored values\n                            restoredKnobsFinal.append (nodeName+\"\['\"+nodeKnob+\"']: \"+nodeExpr+' (index: '+restoredDisplay+')')\n\n                        #force close node (this is a fix for a bug in nuke 9+ :multiple instances of the same panel in the same panel)\n                        if (forceReopen == 'yes'):\n                            me.hideControlPanel()\n\n                        #end loop index knobs\n                    #end node exists\n\n\n                    else:\n                        missingNodes.append(nodeName)\n                        pass    \n        notRestoredIndexList = ', '.join(notRestoredIndexList)\n        restoredKnobsFinal = set(restoredKnobsFinal)\n        restoreLen = str(len(restoredKnobsFinal))\n        restoredKnobsFinal = '\\n'.join(restoredKnobsFinal)\n\n\n        #recount how many expression knobs is sill present in the node, to decide if buttons should be removed\n        ghostList = \[]\n        for s in nuke.thisNode().knobs():\n            if '\[' in s:\n                ghostList.append(s)\n                break\n\n        if len(ghostList) == 0:\n            nuke.thisNode()\['restoreButton'].setVisible(False)\n            nuke.thisNode()\['clearButton'].setVisible(False)\n            nuke.thisNode()\['selectToggle'].setVisible(False)\n\n        \n        missingLen = str(len(missingNodes))\n\n\n        #tell user which expressions was restored\n        if len(missingNodes) == 0 and len(restoredKnobsFinal) > 0:\n            nuke.message('<font color=green>'+str(restoreLen)+' Expression(s) were restored for these knob(s):\\n\\n</font>'+str(restoredKnobsFinal)+'\\n\\n\\n')\n\n\n        #tell user which expressions was NOT restored due to missing nodes\n        elif len(missingNodes) > 0 and len(restoredKnobsFinal) == 0:\n            missingNodes = set(missingNodes)\n            nuke.message('<font color=red>'+missingLen+' Expression(s) for the non-existent node(s) were not restored:\\n</font>'+'\\n'.join(missingNodes)+'\\n\\n\\n<font color=green>Possible restore solution:\\n</font> Check for an earlier version of the nuke script that still have the node(s) in question intact\\n\\nIn case these nodes were deleted by mistake, these expressions will remain in the store list,\\nif you wish to remove them, please use the clear button')\n\n\n        #tell user which expressions was restored and which expressions that was NOT restored due to missing nodes\n        elif len(missingNodes) > 0 and len(restoredKnobsFinal) > 0:\n            missingNodes = set(missingNodes)\n            nuke.message('<font color=green>'+restoreLen+' Expression(s) were restored for these knob(s):\\n</font>'+restoredKnobsFinal+'\\n\\n\\n'+'<font color=red>'+missingLen+' Expression(s) for the non-existent node(s) were not restored:\\n</font>'+'\\n'.join(missingNodes)+'\\n\\n\\n<font color=green>Possible restore solution:\\n</font> Check for an earlier version of the nuke script that still have the node(s) in question intact\\n\\nIn case these nodes were deleted by mistake, these expressions will remain in the store list,\\nif you wish to remove them, please use the clear button')\n\n\n        #force reopen node, if forceReopened was triggered node will have been closed down, this opens the controlpanel of the node again\n        if len(rebuildList) > 0:\n            PySide.QtCore.QTimer.singleShot(0, lambda: me.showControlPanel())"}
 addUserKnob {22 clearButton l "clear selected expressions" t "click this button to clear the selected expression-knob(s) from this node." +HIDDEN T "allGuiKnobs = set()\nremoveSet = set()\nclearCounter = set()\nclearRecounter = set()\nlenCheck = set()\naskUser = 'no'\nanswer = 'no'\n\nme = nuke.thisNode()\n\n\nfor knob in nuke.thisNode().knobs():\n    if '\[' in knob:\n        clearCounter.add(knob)\n\nfor knob in clearCounter:\n    if nuke.thisNode()\[knob].value() == True:\n        askUser = 'yes'\n        break\n\nif askUser == 'no':\n    nuke.message('nothing is selected, nothing to clear.')\nelif askUser == 'yes':\n    if nuke.ask('Are you sure you want to clear the selected expression-knob(s) on this node?'):\n        answer = 'yes'\n\nif answer == 'yes':\n\n    for knob in nuke.thisNode().knobs():\n        if '\[' in knob:\n            allGuiKnobs.add(knob)\n    \n    for i in allGuiKnobs:\n        if nuke.thisNode()\[i].value() == True:\n            removeSet.add(i)\n    \n    for i in removeSet:\n        me.removeKnob(me\[i])\n\n\n    #recount knobs for deciding if buttons should be hidden\n    for knob in nuke.thisNode().knobs():\n        if '\[' in knob:\n            clearRecounter.add(knob)\n\n    if len(clearRecounter) == 0:\n        me\['restoreButton'].setVisible(False)\n        me\['clearButton'].setVisible(False)\n        me\['selectToggle'].setVisible(False)\n" +STARTLINE}
 addUserKnob {22 selectToggle l "select toggle" t "toggle on and off expression checkboxes" -STARTLINE +HIDDEN T "ghostList = \[]\nfor s in nuke.thisNode().knobs():\n    if '\[' in s:\n        ghostList.append(s)\n        break\n\nif len(ghostList) == 0:\n    nuke.thisNode()\['restoreButton'].setVisible(False)\n    nuke.thisNode()\['clearButton'].setVisible(False)\n    nuke.thisNode()\['selectToggle'].setVisible(False)\n\nelse:\n    for name, knob in nuke.thisNode().knobs().items():\n        if knob.Class()=='Boolean_Knob':\n            knob.setValue(not knob.value())"}
 addUserKnob {26 ""}
 addUserKnob {26 copyright l "" +STARTLINE T "<font color=#454545>// fxT_guiFinder v2.1 © Tor Andreassen - www.fxtor.net</font>"}
 addUserKnob {26 ""}
}
