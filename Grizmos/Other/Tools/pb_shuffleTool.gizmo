NoOp {
 name pb_shuffleTool
 knobChanged "#n = nuke.thisNode()\n#n\['sOut'].setEnabled(False)\n#\n#if n.input(0) == None:\n#  print ('no input')\n#else:\n#  print ('input is ' + n.input(0).name())\n#  n\['sOut'].setEnabled(True)\n\n\n\n"
 updateUI "node = nuke.thisNode()\n\nif node.knob('dyna').value() == True:\n    node\[\"shuffleSelected\"].setEnabled(False)\n    node.knob(\"shuffleSelected\").execute()\nelse:\n    node\[\"shuffleSelected\"].setEnabled(True)"
 selected true
 addUserKnob {20 User l "Shuffle Boom" t "by Prasannakuma T Bhat\npbhat99(at)gmail.com\nv0.6"}
 addUserKnob {6 newShuffle l "New Shuffle" +STARTLINE}
 newShuffle true
 addUserKnob {6 pStamp l PostageStamp -STARTLINE}
 pStamp true
 addUserKnob {26 text_2 l "" +STARTLINE}
 addUserKnob {6 cryptoNode l "Exclude Crypto Channels" +STARTLINE}
 cryptoNode true
 addUserKnob {26 cExclude l "" -STARTLINE T "\[?]"}
 addUserKnob {6 utils l "Exclude Utility Channels" +STARTLINE}
 utils true
 addUserKnob {26 exUtils l "" -STARTLINE T "\[?]"}
 addUserKnob {26 ""}
 addUserKnob {4 cList l = M {--------------------------------------------------------------------- rgba}}
 cList rgba
 addUserKnob {22 cListFetch l Fetch -STARTLINE T "import fnmatch\n\n\n\nnode = nuke.thisNode()\n\n\nchannels = node.channels()\nlayers = list( set(\[c.split('.')\[0] for c in channels]) )\n\ncrypto = fnmatch.filter(layers, '*crypto*')\n\n\nutils = fnmatch.filter(layers,'*position*') + fnmatch.filter(layers,'*normal*') + fnmatch.filter(layers,'*depth*') + fnmatch.filter(layers,'*vector*') + fnmatch.filter(layers,'*motion*') + fnmatch.filter(layers,'*utility*')\n\nnode\['cExclude'].setValue('\[Included]')\nnode\['exUtils'].setValue('\[Included]')\n\nif node.knob('cryptoNode').value() == True :\n    layers = list(set(layers) - set(crypto))\n    node\['cExclude'].setValue('\[Excluded]')\nif node.knob('utils').value() == True :\n    layers = list(set(layers) - set(utils))\n    node\['exUtils'].setValue('\[Excluded]')\n\nlayers.sort()\n\nprint (layers)\n\n\nnode\['cList'].setValues(layers)\n\nif crypto == \[]:\n    node\['cExclude'].setValue('\[none Found!]')\nnode\['cList'].setValues(layers)\nif utils == \[]:\n    node\['exUtils'].setValue('\[none Found!]')"}
 addUserKnob {22 clearList l Clear -STARTLINE T "layers = \['---------------------------------------------------------------------', 'rgba']\nnode\['cList'].setValues(layers)\nnode\['cExclude'].setValue('\[?]')\nnode\['exUtils'].setValue('\[?]')"}
 addUserKnob {22 shuffleSelected l "Shuffle it" T "def sanity_channels(layers):\n    \"\"\"For some reasons nuke node.channels() does not return consistent orders for r, g, b.\n\n    Therefore ome re-ordering is necessary as well as connecting a single input to all 4 output layers.\n\n    Args:\n        layers (list): Layer names to re-order.\n\n    \"\"\"\n    if len(layers) == 1 :\n        layers = \[layers\[0] for _ in range(4)]\n    elif len(layers) == 3:\n        layers.append(\"rgba.alpha\")\n    d = \{\".red\": 0, \".green\": 1, \".blue\": 2, \".alpha\": 3\}\n    new_layer = \[i for i in layers]\n    for layer in new_layer:\n        for k, v in d.items():\n            if layer.endswith(k):\n                layers\[v] = layer\n    return layers\n\ny = node.knob('cList').value()\n\nif node\['newShuffle'].value() == True:\n    shuffle_node = nuke.nodes.Shuffle2(label='\[value in1]',\n                                  inputs=\[node],\n                                  in1=y,\n                                  out1=\"rgba\")\n    \n    if y == \"alpha\":\n        channel_in = \['rgba.alpha' for _ in range(4)]\n    else:\n        channel_in = \[layer for layer in node.channels() if layer.split(\".\")\[0] == y]\n        channel_in = sanity_channels(channel_in)\n    \n    channel_out = ('rgba.red', 'rgba.green', 'rgba.blue', 'rgba.alpha')\n    in_2 = 0 if \"depth.Z\" in channel_in or \"alpha\" in channel_in else 1\n    layer_in = (0, 0, 0, in_2)\n    \n    if \"rgba.alpha\" in channel_in:\n        shuffle_node.knob(\"in2\").setValue(\"rgba.alpha\")\n    \n    mapping = (list((zip(layer_in, channel_in, channel_out))))\n    print(mapping)\n    shuffle_node.knob(\"mappings\").setValue(mapping)\n    shuffle_node\['postage_stamp'].setValue(node.knob('pStamp').value())\n\nelse:\n    shuffle_node = nuke.nodes.Shuffle(label='\[value in]',\n                                      inputs=\[node],\n                                      in2='alpha',\n                                      alpha='red2',\n                                      out=\"rgba\")\n    shuffle_node\['in'].setValue(y)\n    shuffle_node\['postage_stamp'].setValue(node.knob('pStamp').value())" +STARTLINE}
 addUserKnob {6 dyna l "     " -STARTLINE}
 addUserKnob {22 sOut l "Shuffle Them All" -STARTLINE T "import fnmatch\n\nlayers = None\ncrypto = None\n\ndef sanity_channels(layers):\n    \"\"\"For some reasons nuke node.channels() does not return consistent orders for r, g, b.\n\n    Therefore ome re-ordering is necessary as well as connecting a single input to all 4 output layers.\n\n    Args:\n        layers (list): Layer names to re-order.\n\n    \"\"\"\n    if len(layers) == 1 :\n        layers = \[layers\[0] for _ in range(4)]\n    elif len(layers) == 3:\n        layers.append(\"rgba.alpha\")\n    d = \{\".red\": 0, \".green\": 1, \".blue\": 2, \".alpha\": 3\}\n    new_layer = \[i for i in layers]\n    for layer in new_layer:\n        for k, v in d.items():\n            if layer.endswith(k):\n                layers\[v] = layer\n    return layers\n\n\nnode = nuke.thisNode()\n\nchannels = node.channels()\nlayers = list( set(\[c.split('.')\[0] for c in channels]) )\n\ncrypto = fnmatch.filter(layers, '*crypto*')\n\nutils = fnmatch.filter(layers,'*position*') + fnmatch.filter(layers,'*normal*') + fnmatch.filter(layers,'*depth*') + fnmatch.filter(layers,'*vector*') + fnmatch.filter(layers,'*motion*') + fnmatch.filter(layers,'*utility*')\n\nif node.knob('cryptoNode').value() == True :\n    layers = list(set(layers) - set(crypto))\nif node.knob('utils').value() == True :\n    layers = list(set(layers) - set(utils))\n\nlayers.sort()\n\n\nprint (layers)\n\nif node\['newShuffle'].value() == True:\n    for y in layers:\n        shuffle_node = nuke.nodes.Shuffle2(label='\[value in1]',\n                                      inputs=\[node],\n                                      selected=True,\n                                      in1=y,\n                                      out1=\"rgba\")\n    \n        if y == \"alpha\":\n            channel_in = \['rgba.alpha' for _ in range(4)]\n        else:\n            channel_in = \[layer for layer in node.channels() if layer.split(\".\")\[0] == y]\n            channel_in = sanity_channels(channel_in)\n    \n        channel_out = ('rgba.red', 'rgba.green', 'rgba.blue', 'rgba.alpha')\n        in_2 = 0 if \"depth.Z\" in channel_in or \"alpha\" in channel_in else 1\n        layer_in = (0, 0, 0, in_2)\n    \n        if \"rgba.alpha\" in channel_in:\n            shuffle_node.knob(\"in2\").setValue(\"rgba.alpha\")\n    \n        mapping = (list((zip(layer_in, channel_in, channel_out))))\n        print(mapping)\n        shuffle_node.knob(\"mappings\").setValue(mapping)\n        shuffle_node\['postage_stamp'].setValue(node.knob('pStamp').value())\n\nelse:\n    for y in layers:\n        shuffle_node = nuke.nodes.Shuffle(label='\[value in]',\n                                          inputs=\[node],\n                                          selected=True,\n                                          in2='alpha',\n                                          alpha='red2',\n                                          out=\"rgba\")\n        shuffle_node\['in'].setValue(y)\n        shuffle_node\['postage_stamp'].setValue(node.knob('pStamp').value())\n#nuke.delete(nuke.thisNode())\n  \n"}
 addUserKnob {26 text l "" +STARTLINE}
 addUserKnob {26 text_1 l "" +STARTLINE +INVISIBLE T "(c) Prasannakumar T Bhat\nv0.6"}
}
